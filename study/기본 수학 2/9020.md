# 문제 이름
### 골드바흐의 추측

## 1. 문제

1보다 큰 자연수 중에서 1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다. 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다. 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.

골드바흐의 추측은 유명한 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다. 이러한 수를 골드바흐 수라고 한다. 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. 예를 들면, 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5, 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다. 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.

2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.

#### 입력
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.


#### 출력
각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다. 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.

#### 제한
-  4 ≤ n ≤ 10,000
#### 예제 입력 1
3</br>
8</br>
10</br>
16</br>

#### 예제 출력 1
3 5</br>
5 5</br>
5 11</br>

출처 : https://www.acmicpc.net/problem/9020

## 2. 해결 방법
소수를 활용하기 위해 아리토스테네스의 체를 이용하여 0부터 10,000 사이의 소수를 배열에 저장해둔다.</br>
표현하고자 하는 수를 N이라고 하면 두 소수는 항상 N/2보다 작거나 같다. 이때 두 소수를 모두 배열에서 찾게 되면 시간 복잡도는 O(N^2)가 된다. 따라서 불필요한 연산을 막기 위해 하나의 수가 p이면 나머지 수는 N-p라는 것을 활용한다.</br>
p가 소수일 때 N-p가 소수인지 판단하여 N-p도 소수인 경우에만 두 수의 차이를 구한다. </br>
이후 두 수의 차이가 가장 작은 경우의 값을 저장해두어 출력한다.


## 3. 배운것
배열에서 두 개의 수를 동시에 가져와야 하는 경우에는 항상 2중 for문을 이용하였다. 하지만 시간 복잡도는 O(N^2)이 되기 때문에 연산량이 증가한다.</br>
위 문제의 경우 하나의 수(p)를 배열에서 가져오면 나머지 수는 항상 N-p이므로 이를 활용하여 시간복잡도를 O(N)으로 줄일 수 있다는 것을 알게 되었다.

## 4. 코드

```C++
#include <stdio.h>
#include <math.h>

int arr[10001] = { 0, };

void eratos();
void find_partition(int);

int main() {

	int T, n;

	eratos();

	scanf("%d", &T);

	for (int i = 0; i < T; i++) {

		scanf("%d", &n);
		find_partition(n);

	}

	return 0;
}

void eratos() {

	for (int i = 2; i < 10001; i++) {
		arr[i] = i;
	}

	for (int i = 2; i < 10001; i++) {

		if (!arr[i]) continue;

		for (int j = 2 * i; j < 10001; j += i) {
			
			arr[j] = 0;

		}

	}

}

void find_partition(int num) {

	int min = 10000;
	int num1, num2;
	int a, b;

	for (int i = 2; i <= num/2; i++) {
		

		num1 = arr[i];
		num2 = num - num1;
		

		if (arr[i] != 0 && arr[num2] != 0 && abs(num1 - num2) < min) {

			min = abs(num1 - num2);
			a = num1;
			b = num2;

		}

	}

	printf("%d %d\n", a, b);

}
```