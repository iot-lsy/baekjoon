# 문제 이름
### 소수 

## 1. 문제
자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.

예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.

#### 입력
입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.</br>
M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.

#### 출력
M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.</br>
단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.

#### 예제 입력 1
60</br>
100

#### 예제 출력 1
620</br>
61

#### 예제 입력 2
64</br>
65

#### 예제 출력 2
-1

## 2. 해결 방법
소수는 1과 자기 자신(N)으로만 나누어지는 수이다. 
따라서 2부터 N-1까지의 값으로 N을 나누었을 때 **0이 되는 경우가 존재**하면 소수가 아니다.
예를 들어 12의 경우 1, 2, 3, 4, 6, 12에서 2부터 11사이에 나누어지는 수가 존재하므로 소수가 아니다.
그런데 모든 숫자는 **제곱근**을 기준으로 나누었을 때 절반으로 나누어진다.

숫자 | 약수 | 제곱근 | floor(제곱근)
--|--|--|--
4| 1, 2, 4 | 2 | 2
8 | 1, 2, 4, 8 | 2.82 | 2
10 | 1, 2, 5, 10 | 3. 16 | 3

이를 통해 어떤 수가 2 ~ floor(제곱근)사이의 값 으로 나누어지는 경우가 존재하면 소수가 아님을 확인할 수 있다.
N과 M은 10000이하의 자연수 이므로 min을 10000으로 초기화하여 제일 먼저 구해지는 소수가 min 변수에 저장될 수 있도록 하였다.

## 3. 배운것
제곱근을 사용하지 않고 2부터 N-1까지 나누는 경우 시간복잡도는 O(N)이 된다. 그러나 제곱근을 사용하여 2부터 floor(제곱근)까지 나누는 경우의 시간 복잡도는 O(sqrt(N))이 된다. 제곱근을 적절히 사용하면 더 빠른 연산속도를 가질 수 있다는 것을 알게되었다.

## 4. 코드

```C++
#include <stdio.h>
#include <math.h>

void find_prime_num(int, int);

int main() {

	int M, N;

	scanf("%d", &N);
	scanf("%d", &M);

	find_prime_num(N, M);

	return 0;
}

void find_prime_num(int N, int M) {

	int check = 0;
	int sum = 0;
	int min = 10000;

	for (int i = N; i <= M; i++) {
		check = 0;
		for (int j = 2; j <= (int)sqrt(i); j++) {

			if (i % j == 0) {
				check = 1;
				break;
			}

		}
		if (!check) {
			if (i != 1) {
				sum += i;
				if (i < min) {
					min = i;
				}
			}
		}
	}

	if (!sum) {
		printf("-1\n");
	}
	else {
		printf("%d\n", sum);
		printf("%d\n", min);
	}
	
}
```